<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- PORTING NOTE: Update title and branding for target runtime -->
  <title>PerfSimPhp - Documentation</title>
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <link rel="stylesheet" href="/css/styles.css">
  <style>
    .docs-container {
      max-width: 900px;
      margin: 0 auto;
      padding: 1rem;
      flex: 1;
      min-width: 0;
    }
    .docs-section {
      background-color: var(--color-card);
      border-radius: var(--radius-md);
      padding: 2rem;
      margin-bottom: 1.5rem;
      box-shadow: var(--shadow-sm);
    }
    .docs-section h2 {
      color: var(--color-primary);
      border-bottom: 2px solid #edebe9;
      padding-bottom: 0.5rem;
      margin-bottom: 1rem;
    }
    .docs-section h3 {
      color: var(--color-text);
      margin-top: 1.5rem;
      margin-bottom: 0.5rem;
    }
    .docs-section code {
      background-color: var(--color-bg);
      padding: 0.2rem 0.4rem;
      border-radius: var(--radius-sm);
      font-family: 'Cascadia Code', 'Consolas', monospace;
    }
    .docs-section pre {
      background-color: #1e1e1e;
      color: #d4d4d4;
      padding: 1rem;
      border-radius: var(--radius-sm);
      overflow-x: auto;
      margin: 1rem 0;
    }
    .docs-section pre code {
      background: none;
      padding: 0;
    }
    .warning-box {
      background-color: #fff4ce;
      border-left: 4px solid var(--color-warning);
      padding: 1rem;
      margin: 1rem 0;
      border-radius: 0 var(--radius-sm) var(--radius-sm) 0;
    }
    .info-box {
      background-color: #e6f3ff;
      border-left: 4px solid var(--color-primary);
      padding: 1rem;
      margin: 1rem 0;
      border-radius: 0 var(--radius-sm) var(--radius-sm) 0;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1rem 0;
    }
    th, td {
      border: 1px solid #edebe9;
      padding: 0.5rem;
      text-align: left;
    }
    th {
      background-color: var(--color-bg);
    }
  </style>
</head>
<body>
  <header>
    <button id="hamburger-btn" class="hamburger-btn attention" aria-label="Open navigation menu">
      <span></span>
      <span></span>
      <span></span>
    </button>
    <!-- PORTING NOTE: Update heading for target runtime -->
    <h1>üêò Performance Problem Simulator - PHP Blessed Image (PHP|8.4)</h1>
    <span id="sku-badge" class="sku-badge">SKU: Local</span>
    <nav>
      <a href="/" class="btn-panel-toggle">üéÆ Dashboard</a>
    </nav>
  </header>

  <!-- Sidebar Drawer Navigation -->
  <div id="sidebar-overlay" class="sidebar-overlay"></div>
  <aside id="sidebar-drawer" class="sidebar-drawer">
    <div class="sidebar-header">
      <h2>üêò PerfSimPhp</h2>
      <button id="sidebar-close" class="sidebar-close" aria-label="Close navigation">&times;</button>
    </div>
    <nav class="sidebar-nav">
      <div class="sidebar-section-label">Application</div>
      <a href="/" class="sidebar-nav-item">
        <span class="nav-icon">üéÆ</span>
        <span class="nav-label">Dashboard<span class="nav-desc">Live metrics & controls</span></span>
      </a>
      <div class="sidebar-divider"></div>
      <div class="sidebar-section-label">Documentation</div>
      <a href="/docs.html" class="sidebar-nav-item active">
        <span class="nav-icon">üìö</span>
        <span class="nav-label">Documentation<span class="nav-desc">API reference & guides</span></span>
      </a>
      <a href="/azure-diagnostics.html" class="sidebar-nav-item">
        <span class="nav-icon">‚òÅÔ∏è</span>
        <span class="nav-label">Azure Diagnostics<span class="nav-desc">Diagnose issues in App Service</span></span>
      </a>
      <a href="/azure-deployment.html" class="sidebar-nav-item">
        <span class="nav-icon">üöÄ</span>
        <span class="nav-label">Deploy to Azure<span class="nav-desc">GitHub Actions + OIDC setup</span></span>
      </a>
      <div class="sidebar-divider"></div>
      <div class="sidebar-section-label">External</div>
      <a href="https://github.com/rhamlett/perfsimphp" target="_blank" class="sidebar-nav-item">
        <span class="nav-icon">üêô</span>
        <span class="nav-label">GitHub Repository<span class="nav-desc">Source code & issues</span></span>
      </a>
    </nav>
    <div class="sidebar-footer">
      Performance Problem Simulator
    </div>
  </aside>

  <div class="docs-page-wrapper">
  <main class="docs-container">

    <section id="overview" class="docs-section">
      <h2>Overview</h2>
      <!-- PORTING NOTE: Update overview description for target runtime -->
      <p>PerfSimPhp is an educational tool designed to help Azure support engineers practice diagnosing common PHP performance problems on Azure App Service. It intentionally generates controllable performance issues that mimic real-world scenarios.</p>
      
      <h3>Features</h3>
      <ul>
        <li><strong>CPU Stress</strong> &mdash; Generate high CPU usage at configurable percentages</li>
        <li><strong>Memory Pressure</strong> &mdash; Allocate and retain memory to simulate leaks</li>
        <!-- PORTING NOTE: Event Loop Blocking ‚Üí Request Thread Blocking for PHP -->
        <li><strong>Request Thread Blocking</strong> &mdash; Block PHP-FPM workers with synchronous operations</li>
        <li><strong>Crash Simulation</strong> &mdash; Trigger fatal errors, exit, or OOM conditions</li>
      </ul>

      <h3>Architecture</h3>
      <!-- PORTING NOTE: Update architecture description and directory tree for target runtime -->
      <p>The application runs on PHP 8.4 with Nginx + PHP-FPM, using APCu or file-based shared storage for cross-request state, and AJAX polling for real-time metrics.</p>
      <pre><code>public/
‚îú‚îÄ‚îÄ index.php               # Front controller (all requests)
‚îú‚îÄ‚îÄ index.html              # Main dashboard
‚îú‚îÄ‚îÄ docs.html               # Documentation
‚îú‚îÄ‚îÄ azure-diagnostics.html  # Diagnostics guide
‚îú‚îÄ‚îÄ azure-deployment.html   # Deployment guide
‚îú‚îÄ‚îÄ css/styles.css          # Shared stylesheet
‚îú‚îÄ‚îÄ js/
‚îÇ   ‚îú‚îÄ‚îÄ polling-client.js   # AJAX polling client (replaces Socket.IO)
‚îÇ   ‚îú‚îÄ‚îÄ charts.js           # Real-time Chart.js charts
‚îÇ   ‚îî‚îÄ‚îÄ dashboard.js        # UI interactions &amp; form handlers

src/
‚îú‚îÄ‚îÄ bootstrap.php           # Autoloader &amp; initialization
‚îú‚îÄ‚îÄ Config.php              # Application configuration
‚îú‚îÄ‚îÄ SharedStorage.php       # Cross-request state (APCu or file)
‚îú‚îÄ‚îÄ Router.php              # URL routing
‚îú‚îÄ‚îÄ Utils.php               # Utility functions
‚îú‚îÄ‚îÄ Middleware/
‚îÇ   ‚îú‚îÄ‚îÄ ErrorHandler.php    # Error handling
‚îÇ   ‚îú‚îÄ‚îÄ RequestLogger.php   # Request logging
‚îÇ   ‚îî‚îÄ‚îÄ Validation.php      # Input validation
‚îú‚îÄ‚îÄ Services/
‚îÇ   ‚îú‚îÄ‚îÄ CpuStressService.php      # Background CPU workers via exec()
‚îÇ   ‚îú‚îÄ‚îÄ MemoryPressureService.php # Shared storage memory allocation
‚îÇ   ‚îú‚îÄ‚îÄ BlockingService.php       # FPM worker pool blocking

‚îÇ   ‚îú‚îÄ‚îÄ CrashService.php          # Worker crash triggers
‚îÇ   ‚îú‚îÄ‚îÄ CrashTrackingService.php  # Crash statistics tracking
‚îÇ   ‚îú‚îÄ‚îÄ LoadTestService.php       # Azure Load Testing endpoint
‚îÇ   ‚îú‚îÄ‚îÄ MetricsService.php        # System metrics collection
‚îÇ   ‚îú‚îÄ‚îÄ EventLogService.php       # Event ring buffer
‚îÇ   ‚îî‚îÄ‚îÄ SimulationTrackerService.php
‚îî‚îÄ‚îÄ Controllers/
    ‚îú‚îÄ‚îÄ HealthController.php
    ‚îú‚îÄ‚îÄ MetricsController.php
    ‚îú‚îÄ‚îÄ CpuController.php
    ‚îú‚îÄ‚îÄ MemoryController.php
    ‚îú‚îÄ‚îÄ BlockingController.php
    ‚îú‚îÄ‚îÄ CrashController.php
    ‚îú‚îÄ‚îÄ LoadTestController.php
    ‚îî‚îÄ‚îÄ AdminController.php

workers/
‚îî‚îÄ‚îÄ cpu-worker.php          # Background CPU stress process</code></pre>
    </section>

    <section id="cpu-stress" class="docs-section">
      <h2>CPU Stress Simulation</h2>
      <!-- PORTING NOTE: Update implementation details for target runtime's process model -->
      <p>Generates high CPU usage using separate background PHP processes via <code>exec()</code>.</p>

      <h3>How It Works</h3>
      <p>Unlike naive CPU burning in the request thread (which would block the FPM worker), this simulation spawns separate background processes that each run <code>hash_pbkdf2()</code> in a tight loop. The OS scheduler distributes these processes across CPU cores.</p>
      
      <div class="info-box">
        <!-- PORTING NOTE: Update runtime insight for target runtime -->
        <strong>üêò PHP Insight:</strong> CPU-intensive work should be isolated from PHP-FPM workers. Background processes via <code>exec("nohup php worker.php &amp;")</code> guarantee true multi-core utilization without blocking request handling.
      </div>

      <h3>Usage</h3>
      <pre><code>POST /api/simulations/cpu/start
Content-Type: application/json

{
  "targetLoadPercent": 75,
  "durationSeconds": 30
}</code></pre>

      <h3>Parameters</h3>
      <table>
        <tr><th>Parameter</th><th>Range</th><th>Description</th></tr>
        <tr><td>targetLoadPercent</td><td>1-100</td><td>Target CPU usage percentage (spawns proportional workers)</td></tr>
        <tr><td>durationSeconds</td><td>1-300</td><td>How long to run the simulation</td></tr>
      </table>

      <h3>Expected Effects</h3>
      <ul>
        <li>CPU tile/chart increases to target percentage</li>
        <!-- PORTING NOTE: Update expected effects for target runtime -->
        <li>FPM workers stay available (work is in background processes)</li>
        <li>Request latency may increase slightly due to CPU contention</li>
        <li>Multiple <code>php</code> processes visible in <code>top</code>/<code>htop</code></li>
      </ul>

      <div class="info-box">
        <strong>üìä About CPU Metrics:</strong> The dashboard reads CPU from <code>/proc/stat</code> and <code>sys_getloadavg()</code>. This may show fluctuations at idle due to PHP-FPM worker management and container scheduling. Focus on the <em>trend</em> during simulations, not individual spikes. Production tools (Azure Monitor) sample every 1 minute with averaging.
      </div>

      <h3>Diagnostic Tools</h3>
      <ul>
        <li><code>top</code> / <code>htop</code> &mdash; View all PHP processes</li>
        <li><code>ps aux | grep php</code> &mdash; See background worker processes</li>
        <li>Azure App Service Diagnostics &rarr; CPU drill-down</li>
        <li>Application Insights &rarr; Performance metrics</li>
      </ul>
    </section>

    <section id="memory-pressure" class="docs-section">
      <h2>Memory Pressure Simulation</h2>
      <!-- PORTING NOTE: Update memory description for target runtime -->
      <p>Allocates and retains large data blocks in shared storage to simulate memory leaks across PHP-FPM workers.</p>

      <h3>How It Works</h3>
      <p>Uses APCu shared memory (or file-based storage) to allocate large strings filled with random data. Data is held in shared storage until explicitly released, visible to all FPM workers. Multiple allocations can coexist (stacking behavior).</p>

      <div class="info-box">
        <strong>üêò PHP Insight:</strong> PHP-FPM uses multiple worker processes. Memory in APCu is shared across workers. File-based storage creates actual disk usage. The <code>memory_limit</code> INI setting controls per-request memory, but shared storage allocations bypass this limit.
      </div>

      <h3>Usage</h3>
      <pre><code># Allocate memory
POST /api/simulations/memory/allocate
{"sizeMb": 100}

# Release all memory
POST /api/simulations/memory/release</code></pre>

      <h3>Parameters</h3>
      <table>
        <tr><th>Parameter</th><th>Range</th><th>Description</th></tr>
        <tr><td>sizeMb</td><td>1-2000</td><td>Memory to allocate in megabytes</td></tr>
      </table>

      <h3>Expected Effects</h3>
      <ul>
        <li>Memory usage increases by allocation size</li>
        <li>RSS memory increases proportionally</li>
        <!-- PORTING NOTE: Update GC-specific behavior for target runtime -->
        <li>PHP-FPM workers accessing shared data contribute to total memory</li>
        <li>With file-based storage, disk usage increases</li>
      </ul>

      <h3>Diagnostic Tools</h3>
      <ul>
        <li>Azure App Service &rarr; Memory metrics</li>
        <li><code>free -m</code> &mdash; System memory overview</li>
        <li><code>ps aux --sort=-%mem | head</code> &mdash; Top memory consumers</li>
        <li>Application Insights &rarr; customMetrics for memory stats</li>
      </ul>
    </section>

    <!-- PORTING NOTE: This entire section changes based on the target runtime's concurrency model.
         Node.js: Event Loop Blocking (single-threaded event loop)
         PHP: Request Thread Blocking (multi-process FPM workers)
         Go: Goroutine blocking, .NET: ThreadPool exhaustion, etc. -->
    <section id="request-thread-blocking" class="docs-section">
      <h2>Request Thread Blocking Simulation</h2>
      <p>Demonstrates how CPU-intensive synchronous operations inside PHP-FPM workers can exhaust the worker pool, causing request queuing.</p>

      <div class="warning-box">
        <strong>‚ö†Ô∏è Warning:</strong> During this simulation, individual PHP-FPM workers will be blocked and unable to serve other requests. If all workers are blocked, the server becomes completely unresponsive to new requests.
      </div>

      <h3>How It Works</h3>
      <p>Performs synchronous <code>hash_pbkdf2()</code> directly inside a PHP-FPM worker process. While the worker is blocked, it cannot handle any other requests. When enough workers are blocked, the entire FPM pool is exhausted and new requests queue at the Nginx level.</p>

      <div class="info-box">
        <strong>üêò PHP Insight:</strong> In PHP, blocking one FPM worker only blocks that one request ‚Äî you need to exhaust the entire worker pool to see queueing. This is how worker pool exhaustion manifests in request-per-process architectures.
      </div>

      <h3>Key Difference from CPU Stress</h3>
      <p>CPU stress uses <em>background processes</em> (FPM workers stay available). Request thread blocking runs <em>inside an FPM worker</em> (that worker becomes unavailable). Check the FPM Workers Busy metric to distinguish them!</p>

      <h3>Usage</h3>
      <pre><code>POST /api/simulations/blocking/start
{"durationSeconds": 5}</code></pre>

      <h3>Symptoms to Observe</h3>
      <ul>
        <li>FPM Workers Busy count increases during blocking</li>
        <li>New requests queue when all workers are occupied</li>
        <li>Probe dots turn yellow/orange as workers become scarce</li>
        <li>Request latency increases as FPM pool is exhausted</li>
        <li>Health checks may timeout if no workers are available</li>
      </ul>

      <h3>Diagnostic Tools</h3>
      <ul>
        <li><code>php-fpm status page</code> &mdash; View active/idle worker counts</li>
        <li><code>ps aux | grep php-fpm</code> &mdash; See worker process states</li>
        <li>Nginx access logs &mdash; Look for 502/504 errors during pool exhaustion</li>
        <li>Azure App Service Diagnostics &rarr; PHP worker analysis</li>
      </ul>
    </section>

    <section id="crash-simulation" class="docs-section">
      <h2>Crash Simulation</h2>
      <!-- PORTING NOTE: Update crash description for target runtime -->
      <p>Intentionally crashes a PHP-FPM worker process for testing crash recovery and observing restart behavior.</p>

      <div class="warning-box">
        <strong>‚ö†Ô∏è Warning:</strong> These operations will terminate the PHP-FPM worker process. PHP-FPM master will automatically respawn it. The dashboard will briefly lose connectivity for the affected request.
      </div>

      <h3>Crash Types</h3>
      <!-- PORTING NOTE: Update crash types and methods for target runtime -->
      <table>
        <tr><th>Type</th><th>Endpoint</th><th>Method</th><th>Effect</th></tr>
        <tr><td>FailFast</td><td><code>/api/simulations/crash/failfast</code></td><td><code>exit(1)</code></td><td>Immediate process termination</td></tr>
        <tr><td>Stack Overflow</td><td><code>/api/simulations/crash/stackoverflow</code></td><td>Infinite recursion</td><td>Call stack exhausted</td></tr>
        <tr><td>Fatal Error</td><td><code>/api/simulations/crash/exception</code></td><td><code>trigger_error(E_USER_ERROR)</code></td><td>Fatal error terminates worker</td></tr>
        <tr><td>OOM</td><td><code>/api/simulations/crash/oom</code></td><td>Exceed <code>memory_limit</code></td><td>Memory exhaustion, worker killed</td></tr>
      </table>

      <h3>Expected Behavior</h3>
      <ul>
        <li>FPM worker process terminates immediately</li>
        <li>Response is sent before crash via <code>fastcgi_finish_request()</code></li>
        <li>PHP-FPM master auto-restarts the worker automatically</li>
        <li>Dashboard shows session crash counter incrementing</li>
        <li>Event Log shows crash initiated messages</li>
        <li>Shared storage (APCu/files) persists across worker restarts</li>
        <li>Use "Crash Multiple Workers" to send concurrent crash requests for more visible impact</li>
      </ul>

      <div class="info-box">
        <strong>üêò PHP Insight:</strong> In PHP, a crash only kills one FPM worker ‚Äî other workers continue serving requests. The FPM master respawns the crashed worker automatically, providing built-in fault isolation.
      </div>

      <h3>Diagnostic Tools</h3>
      <ul>
        <li>Azure App Service &rarr; Diagnose and Solve Problems &rarr; Application Crashes</li>
        <li>Log Stream (real-time crash logs)</li>
        <li>Kudu &rarr; LogFiles &rarr; php</li>
        <li>PHP-FPM slow log: <code>/var/log/php-fpm/slow.log</code></li>
        <li>Application Insights &rarr; Failures blade</li>
      </ul>
    </section>

    <section id="diagnostics" class="docs-section">
      <h2>Diagnostics</h2>
      <p>For comprehensive guidance on diagnosing PHP performance issues, see the dedicated <a href="/azure-diagnostics.html"><strong>Azure Diagnostics Guide</strong></a>.</p>
      
      <h3>What's Covered</h3>
      <ul>
        <li><strong>Understanding Metrics</strong> &mdash; What CPU, memory, FPM workers, and latency metrics mean</li>
        <li><strong>PHP-FPM Architecture</strong> ‚Äî Understanding the worker process model and resource management</li>
        <li><strong>Diagnostic Scenarios</strong> &mdash; Step-by-step walkthroughs for each simulation type</li>
        <li><strong>Azure Tools</strong> &mdash; App Service Diagnostics, Application Insights, Kudu console</li>
        <li><strong>Linux Tools</strong> &mdash; Process monitoring, PHP debugging, network analysis</li>
        <li><strong>AppLens Queries</strong> &mdash; Ready-to-use KQL queries for Azure diagnostics</li>
      </ul>
      
      <div class="info-box">
        <strong>üí° Tip:</strong> Open the <a href="/azure-diagnostics.html">Azure Diagnostics Guide</a> in a separate tab while running simulations to follow along with the diagnostic workflows.
      </div>
    </section>

    <section id="api-reference" class="docs-section">
      <h2>API Reference</h2>
      
      <h3>Health &amp; Metrics</h3>
      <table>
        <tr><th>Endpoint</th><th>Method</th><th>Description</th></tr>
        <tr><td><code>/api/health</code></td><td>GET</td><td>Health check with uptime and environment info</td></tr>
        <tr><td><code>/api/metrics/probe</code></td><td>GET</td><td>Lightweight probe for latency monitoring</td></tr>
        <tr><td><code>/api/metrics/internal-probes</code></td><td>GET</td><td>Batch internal probes via localhost (bypasses stamp frontend)</td></tr>
        <tr><td><code>/api/metrics</code></td><td>GET</td><td>Current system metrics (CPU, memory, FPM workers)</td></tr>
      </table>
      
      <h3>Simulations</h3>
      <!-- PORTING NOTE: Update API endpoints to match target runtime's routing -->
      <table>
        <tr><th>Endpoint</th><th>Method</th><th>Description</th></tr>
        <tr><td><code>/api/simulations</code></td><td>GET</td><td>List all active simulations</td></tr>
        <tr><td><code>/api/simulations/cpu/start</code></td><td>POST</td><td>Start CPU stress (background processes)</td></tr>
        <tr><td><code>/api/simulations/cpu/stop</code></td><td>POST</td><td>Stop CPU stress</td></tr>
        <tr><td><code>/api/simulations/memory/allocate</code></td><td>POST</td><td>Allocate memory</td></tr>
        <tr><td><code>/api/simulations/memory/release</code></td><td>POST</td><td>Release all memory</td></tr>
        <tr><td><code>/api/simulations/blocking/start</code></td><td>POST</td><td>Block FPM worker thread</td></tr>
      </table>
      
      <h3>Crash Endpoints</h3>
      <table>
        <tr><th>Endpoint</th><th>Method</th><th>Description</th></tr>
        <tr><td><code>/api/simulations/crash/failfast</code></td><td>POST</td><td>FailFast &mdash; exit(1)</td></tr>
        <tr><td><code>/api/simulations/crash/stackoverflow</code></td><td>POST</td><td>Stack Overflow &mdash; Infinite Recursion</td></tr>
        <tr><td><code>/api/simulations/crash/exception</code></td><td>POST</td><td>Fatal Error &mdash; trigger_error()</td></tr>
        <tr><td><code>/api/simulations/crash/oom</code></td><td>POST</td><td>Memory Exhaustion &mdash; Exceed memory_limit</td></tr>
        <tr><td><code>/api/simulations/crash/stats</code></td><td>GET</td><td>Get crash statistics and active worker counts</td></tr>
      </table>
      
      <h3>Admin</h3>
      <table>
        <tr><th>Endpoint</th><th>Method</th><th>Description</th></tr>
        <tr><td><code>/api/admin/status</code></td><td>GET</td><td>Admin status with configuration</td></tr>
        <tr><td><code>/api/admin/events</code></td><td>GET</td><td>Event log (limit via ?limit=N)</td></tr>
        <tr><td><code>/api/admin/system-info</code></td><td>GET</td><td>System info (CPUs, memory, PHP config)</td></tr>
      </table>

      <!-- PORTING NOTE: Node.js has WebSocket events via Socket.IO.
           PHP uses AJAX polling ‚Äî document the polling endpoints instead. -->
      <h3>AJAX Polling (Real-Time Data)</h3>
      <p>The dashboard uses AJAX polling to receive real-time updates (no WebSocket):</p>
      <table>
        <tr><th>Endpoint</th><th>Poll Interval</th><th>Description</th></tr>
        <tr><td><code>/api/metrics</code></td><td>250ms</td><td>System metrics (CPU, memory, FPM workers)</td></tr>
        <tr><td><code>/api/metrics/internal-probes</code></td><td>1000ms</td><td>Batch latency probes via internal curl (10 probes @ 100ms)</td></tr>
        <tr><td><code>/api/admin/events</code></td><td>2000ms</td><td>Event log updates</td></tr>
      </table>
      <p><em>Latency probes use internal curl to localhost:8080, bypassing Azure's stamp frontend. Results are dispatched to the chart at 100ms intervals, giving 10 samples/sec with only 1 request/sec to AppLens.</em></p>
    </section>

    <section id="load-testing" class="docs-section">
      <h2>Azure Load Testing</h2>
      <p>The Performance Problem Simulator includes a dedicated load testing endpoint designed for use with Azure Load Testing. This endpoint simulates realistic application behavior that degrades gracefully under load.</p>

      <h3>Load Test Endpoint</h3>
      <p>Unlike other simulation endpoints, this one does NOT appear in the dashboard UI and is meant for automated load testing scenarios only.</p>
      <table>
        <tr><th>Endpoint</th><th>Method</th><th>Description</th></tr>
        <tr><td><code>/api/loadtest</code></td><td>GET</td><td>Execute load test with query parameters</td></tr>
        <tr><td><code>/api/loadtest/stats</code></td><td>GET</td><td>Get current concurrent request statistics</td></tr>
      </table>

      <h3>Usage</h3>
      <p>Use the <code>GET /api/loadtest</code> endpoint directly in Azure Load Testing &mdash; no JMeter script required:</p>
      <pre><code># With defaults (100ms CPU work, 5MB memory, 500ms hold)
https://perfsimphp.azurewebsites.net/api/loadtest

# Custom CPU work duration
https://perfsimphp.azurewebsites.net/api/loadtest?workMs=200

# Higher memory with longer hold (visible on dashboard chart)
https://perfsimphp.azurewebsites.net/api/loadtest?workMs=100&amp;memoryKb=10000&amp;holdMs=1000

# Maximum stress (5s work, 50MB memory)
https://perfsimphp.azurewebsites.net/api/loadtest?workMs=5000&amp;memoryKb=50000</code></pre>

      <h3>Query Parameters</h3>
      <table>
        <tr><th>Parameter</th><th>Default</th><th>Max</th><th>Description</th></tr>
        <tr><td><code>workMs</code></td><td>100</td><td>5000</td><td>Duration of CPU work in milliseconds (uses hash_pbkdf2)</td></tr>
        <tr><td><code>memoryKb</code></td><td>5000</td><td>50000</td><td>Memory to allocate per request in KB</td></tr>
        <tr><td><code>holdMs</code></td><td>500</td><td>5000</td><td>Time to hold memory after CPU work (ms). Ensures dashboard can capture memory usage.</td></tr>
      </table>

      <div class="info-box">
        <strong>Legacy Parameters:</strong> <code>targetDurationMs</code> and <code>memorySizeKb</code> are still supported as aliases for backwards compatibility.
      </div>

      <h3>Design Philosophy</h3>
      <ul>
        <li><strong>Short Bursts:</strong> Each request does ~100ms of real work, then returns</li>
        <li><strong>Memory Visibility:</strong> Memory is held for <code>holdMs</code> after CPU work so dashboard metrics can capture it</li>
        <li><strong>Fast Turnover:</strong> Workers return quickly, preventing total pool exhaustion</li>
        <li><strong>Natural Degradation:</strong> Under heavy load, requests queue up (realistic back-pressure)</li>
        <li><strong>Dashboard Resilience:</strong> Metrics endpoints use a dedicated FPM pool (see below)</li>
      </ul>

      <h3>Stats Logging</h3>
      <p>Every 60 seconds during active load testing, a summary is logged to the event log:</p>
      <pre><code>üìä Load Test (60s): 1523 requests, 112ms avg, 426ms max, 25.4 RPS</code></pre>

      <h3>Dual FPM Pool Architecture</h3>
      <p>To keep the dashboard responsive during load testing, the application routes traffic to two separate PHP-FPM pools:</p>
      <table>
        <tr><th>Pool</th><th>Port</th><th>Workers</th><th>Routes</th></tr>
        <tr><td>Main (www)</td><td>9000</td><td>~8</td><td><code>/api/loadtest/*</code>, <code>/api/simulations/*</code>, <code>/api/metrics/probe</code></td></tr>
        <tr><td>Metrics</td><td>9001</td><td>4</td><td><code>/api/metrics</code>, <code>/api/metrics/internal-probes</code>, <code>/api/health/*</code>, <code>/api/admin/events</code></td></tr>
      </table>
      <p>This ensures the dashboard can always poll for metrics, even when all main workers are busy with load test requests. The probe endpoint uses the main pool so it measures actual load test latency.</p>

      <h3>What It Tests</h3>
      <ul>
        <li><strong>CPU</strong> &mdash; Real hash_pbkdf2() cryptographic work</li>
        <li><strong>Memory</strong> &mdash; Buffers allocated and held for request duration</li>
        <li><strong>FPM Workers</strong> &mdash; Worker utilization under concurrent load</li>
        <li><strong>Response Time</strong> &mdash; Increases naturally as requests queue</li>
      </ul>

      <div class="info-box">
        <strong>üìò Full Documentation:</strong> See the <a href="/azure-diagnostics.html#load-testing">Azure Diagnostics Guide</a> for detailed setup instructions, tuning scenarios, and diagnostic techniques.
      </div>
    </section>
  </main>

  <!-- Right Sidebar: On This Page -->
  <aside class="docs-right-sidebar">
    <div class="sidebar-card">
      <div class="sidebar-title">ON THIS PAGE</div>
      <ul class="sidebar-links" id="page-nav">
        <li><a href="#overview">üéØ Overview</a></li>
      </ul>
      <div class="sidebar-section-label">SIMULATIONS</div>
      <ul class="sidebar-links" id="page-nav-sims">
        <li><a href="#cpu-stress">üî• CPU Stress</a></li>
        <li><a href="#memory-pressure">üìä Memory Pressure</a></li>
        <!-- PORTING NOTE: Update section link for target runtime -->
        <li><a href="#request-thread-blocking">üßµ Request Thread Blocking</a></li>
        <li><a href="#crash-simulation">üí• Crash Simulation</a></li>
      </ul>
      <div class="sidebar-section-label">REFERENCE</div>
      <ul class="sidebar-links" id="page-nav-ref">
        <li><a href="#diagnostics">üî¨ Diagnostics</a></li>
        <li><a href="#api-reference">üìã API Reference</a></li>
        <li><a href="#load-testing">üìà Azure Load Testing</a></li>
      </ul>
    </div>
  </aside>
  </div><!-- /docs-page-wrapper -->

  <footer>
    <p>Performance Problem Simulator &mdash; Educational Tool for Azure App Service Diagnostics</p>
    <p>Created by <a href="https://speckit.org/" target="_blank">SpecKit</a> in collaboration with <a href="mailto:rhamlett@microsoft.com">Richard Hamlett</a></p>
    <p id="build-info">Build: Loading...</p>
  </footer>
  <script>
    // Load environment info for SKU badge
    fetch('/api/health')
      .then(r => r.json())
      .then(data => {
        const badge = document.getElementById('sku-badge');
        if (badge && data.environment) badge.textContent = 'SKU: ' + (data.environment.sku || 'Local');
        // Load build info for footer
        const buildInfo = document.getElementById('build-info');
        if (buildInfo && data.buildTimestamp) {
          buildInfo.textContent = 'Build: ' + data.buildTimestamp;
        }
      })
      .catch(() => {});

    // Sidebar drawer toggle
    const hamburgerBtn = document.getElementById('hamburger-btn');
    const sidebarOverlay = document.getElementById('sidebar-overlay');
    const sidebarDrawer = document.getElementById('sidebar-drawer');
    const sidebarClose = document.getElementById('sidebar-close');

    function openSidebar() {
      hamburgerBtn.classList.remove('attention');
      hamburgerBtn.classList.add('active');
      sidebarOverlay.classList.add('active');
      sidebarDrawer.classList.add('active');
    }

    function closeSidebar() {
      hamburgerBtn.classList.remove('active');
      sidebarOverlay.classList.remove('active');
      sidebarDrawer.classList.remove('active');
    }

    hamburgerBtn.addEventListener('click', openSidebar);
    sidebarOverlay.addEventListener('click', closeSidebar);
    sidebarClose.addEventListener('click', closeSidebar);

    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') closeSidebar();
    });

    // Scroll-spy: highlight active section in right sidebar
    (function() {
      const links = document.querySelectorAll('#page-nav a, #page-nav-sims a, #page-nav-ref a');
      const sections = [];
      links.forEach(link => {
        const id = link.getAttribute('href').slice(1);
        const el = document.getElementById(id);
        if (el) sections.push({ id, el, link });
      });
      function updateActive() {
        let current = sections[0];
        for (const s of sections) {
          if (s.el.getBoundingClientRect().top <= 100) current = s;
        }
        links.forEach(l => l.classList.remove('active'));
        if (current) current.link.classList.add('active');
      }
      window.addEventListener('scroll', updateActive, { passive: true });
      updateActive();
    })();
  </script>
</body>
</html>
